POJ 3461 （KMP)

两个字符串W和T，问W在T中出现几次。

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char p[1000000+10],s[1000000+10];
int nxt[1000000+10];
int n,m;
void GetNext()
{
    int i = 0, j = -1;
    nxt[i] = j;
    while(i < n)
    {
        if(j == -1 || p[i] == p[j])
        {
            nxt[++i] = ++j;
        }
        else
        {
            j = nxt[j];
        }
    }
}
int ans;
int KMP()
{
    int i = 0, j = 0;
    while(i < m)
    {
        if(j == -1 || s[i] == p[j])
        {
            i++,j++;
        }
        else
        {
            j = nxt[j];
        }
        if(j == n)
        {
            ans++;
            j = nxt[j];
        }
    }
}

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%s %s", p, s);
        n = strlen(p);
        m = strlen(s);
        GetNext();
        ans = 0;
        KMP();
        printf("%d\n",ans);
    }
}

```

POJ 2142

两种无限多的砝码a和b，问能否用最少的a和b通过天平称出c。（扩展欧几里得）

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
void exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
}
int main()
{
    int a,b,c;
    while(~scanf("%d%d%d",&a,&b,&c))
    {
        if(a==0&&b==0&&c==0) break;

        int g=__gcd(a,b);
        a/=g,b/=g,c/=g;

        int x,y;
        exgcd(a,b,x,y);

        int x1=(x*c%b+b)%b;
        int y1=abs((c-a*x1)/b);

        int y2=(y*c%a+a)%a;
        int x2=abs((c-y2*b)/a);
        
        if(x1+y1<=x2+y2)
        {
            printf("%d %d\n",x1,y1);
        }
        else
        {
            printf("%d %d\n",x2,y2);
        }
    }
}

```

POJ 1986

求树上两点之间的距离（倍增LCA）

```
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
using namespace  std;
const int maxn=2e5+10;
int fa[maxn][25];
int dis[maxn][25];
int deep[maxn];
bool vis[maxn];
struct node
{
	int v, w;
};
vector<node> vec[maxn];
void dfs(int x)
{
    vis[x]=1;
    for(int i=1;i<=20;i++)
    {
        if(deep[x]>=(1<<i))
        {
            fa[x][i]=fa[fa[x][i-1]][i-1];
            dis[x][i]=dis[fa[x][i-1]][i-1]+dis[x][i-1];
        }
    }
    for(int i=0;i<vec[x].size();i++)
    {
        int u=vec[x][i].v;
        if(!vis[u])
        {
            deep[u]=deep[x]+1;
            fa[u][0]=x;
            dis[u][0]=vec[x][i].w;
            dfs(u);
        }

    }
}
int lca(int x,int y)
{
    if(deep[x]<deep[y])
    {
        swap(x,y);
    }
    int t=deep[x]-deep[y];
    for(int i=0;i<=20;i++)
    {
        if((t&(1<<i))!=0)
        {
            x=fa[x][i];
        }
        if(x==y)
        {
            return x;
        }
    }
    for(int i=20;i>=0;i--)
    {
        if(fa[x][i]!=fa[y][i])
        {
            x=fa[x][i],y=fa[y][i];
        }
    }
    return fa[x][0];
}
int query(int x,int y)
{
    int ans=0;
    int t=deep[x]-deep[y];
    for(int i=0;i<=20;i++)
    {
        if((t&(1<<i))!=0)
        {
            ans+=dis[x][i];
            x=fa[x][i];
        }
    }
    return ans;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        char c;
        scanf("%d%d%d",&x,&y,&z);
        cin>>c;
        vec[x].push_back((node){y,z});
        vec[y].push_back((node){x,z});
    }
    
    dfs(1);

    int k;
    scanf("%d",&k);
    while(k--)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        int f=lca(u,v);
        printf("%d\n",query(u,f)+query(v,f));
    }
}

```

POJ 2533（LIS)

求最长上升子序列

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[1005];
int dp[1005];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    dp[1]=a[1];
    int cnt=1;
    for(int i=2;i<=n;i++)
    {
        if(a[i]>dp[cnt])
        {
            cnt++;
            dp[cnt]=a[i];
        }
        else
        {
            *lower_bound(dp+1,dp+cnt+1,a[i])=a[i];
        }
    }
    printf("%d\n",cnt);
}

```

HDU 4970（树状数组）

在长度为n的区间，有t座塔攻击范围和攻击力，m个血量为h怪物，从x走到n，问最终有几个怪物可以活下来。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const long long maxn = 1e5+10;
long long c[maxn];
long long lowbit(long long x)
{
    return x&(-x);
}
long long add(long long i,long long v)
{
    while(i<maxn)
    {
        c[i]+=v;
        i+=lowbit(i);
    }
}
long long ask(long long i)
{
    long long ans=0;
    while(i>0)
    {
        ans+=c[i];
        i-=lowbit(i);
    }
    return ans;
}
long long sum[maxn];
int main()
{
    long long n;
    while(~scanf("%lld",&n))
    {
        if(n==0) break;
        for(long long i=1;i<=n+1;i++)
        {
            c[i]=0;
            sum[i]=0;
        }
        long long t;
        scanf("%lld",&t);
        for(long long i=1;i<=t;i++)
        {
            long long l,r,x;
            scanf("%lld%lld%lld",&l,&r,&x);
            add(l,x);
            add(r+1,-x);
        }
        for(long long i=n;i>=1;i--)
        {
            sum[i]=sum[i+1]+ask(i);
        }
        long long m;
        scanf("%lld",&m);
        long long ans=0;
        for(long long i=1;i<=m;i++)
        {
            long long h,x;
            scanf("%lld%lld",&h,&x);
            if(sum[x]<h)
            {
                ans++;
            }
        }
        printf("%lld\n",ans);
    }
}

```

POJ 3468（线段树）

长度为n的序列，Q表示查询，C表示区间加。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const long long maxn=1e5+10;
struct cc{
    long long l,r;
    long long add,sum;
}tree[maxn<<2];
long long a[maxn];
void update(long long p)
{
    tree[p].sum=tree[p*2].sum+tree[p*2+1].sum;
    return;
}
void spread(long long p)
{
    if(tree[p].add)
    {
        tree[p*2].add+=tree[p].add;
        tree[p*2].sum+=(tree[p*2].r-tree[p*2].l+1)*tree[p].add;
        tree[p*2+1].add+=tree[p].add;
        tree[p*2+1].sum+=(tree[p*2+1].r-tree[p*2+1].l+1)*tree[p].add;
        tree[p].add=0;
    }
    update(p);
    return;
}
void build(long long l,long long r,long long p)
{
    tree[p].l=l,tree[p].r=r;
    if(l==r)
    {
        tree[p].sum=a[l];
        return;
    }
    spread(p);
    long long mid=(l+r)/2;
    build(l,mid,p*2);
    build(mid+1,r,p*2+1);
    update(p);
}
void change(long long l,long long r,long long p,long long  v)
{
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        tree[p].add+=v;
        tree[p].sum+=(tree[p].r-tree[p].l+1)*v;
        return;
    }
    spread(p);
    long long mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid) change(l,r,p*2,v);
    if(mid+1<=r) change(l,r,p*2+1,v);
    update(p);
    return;
}
long long ask(long long l,long long r,long long p)
{
    long long ans=0;
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        return tree[p].sum;
    }
    spread(p);
    long long mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid) ans+=ask(l,r,p*2);
    if(mid+1<=r) ans+=ask(l,r,p*2+1);
    update(p);
    return ans;
}
int main()
{
    long long n,q;
    scanf("%lld%lld",&n,&q);
    for(long long i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    build(1,n,1);
    while(q--)
    {
        char c[2];
        scanf("%s",c);
        if(c[0]=='Q')
        {
            long long l,r;
            scanf("%lld%lld",&l,&r);
            printf("%lld\n",ask(l,r,1));
        }
        if(c[0]=='C')
        {
            long long l,r;
            long long v;
            scanf("%lld%lld%lld",&l,&r,&v);
            change(l,r,1,v);
        }
    }
    return 0;
}

```

